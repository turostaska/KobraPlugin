{
  parserClass="com.kobra.plugin.parser.KobraParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Kobra"
  psiImplClassSuffix="Impl"
  psiPackage="com.kobra.plugin.kobraplugin.psi"
  psiImplPackage="com.kobra.plugin.kobraplugin.psi.impl"

  elementTypeHolderClass="com.kobra.plugin.kobraplugin.psi.KobraTypes"
  elementTypeClass="com.kobra.plugin.kobraplugin.psi.KobraElementType"
  tokenTypeClass="com.kobra.plugin.kobraplugin.psi.KobraTokenType"

  tokens=[
  IMPORT='import'
  CLASS_='class'
  INTERFACE='interface'
  FUN='fun'
  CONSTRUCTOR='constructor'
  IF='if'
  ELSE='else'
  TRY='try'
  CATCH='catch'
  FINALLY='finally'
  FOR='for'
  RETURN='return'
  IS='is'
  IN='in'
  NOT_IS='\!is'
  NOT_IN='\!in'
  AS='as'
  AS_SAFE='as\?'
  THIS='this'
  SUPER='super'
  THROW='throw'
  CONTINUE='continue'
  BREAK='break'
  WHEN='when'

  // SECTION=lexicalModifiers

  PUBLIC='public'
  PRIVATE_='private'
  PROTECTED='protected'

  VAL='val'
  VAR='var'

  STRING='regexp:"[^\r\n]*"'

  LPAREN='\('
  RPAREN='\)'
  LCURL='\{'
  RCURL='\}'
  COMMA=','
  COLON=':'
  COLONCOLON='::'
  ASSIGNMENT='='
  QUEST='\?' Hidden
  CONJ='&&'
  DISJ='\|\|'
  SEMICOLON=';'
  DOT='\.'
  QUOTE='\"'
  EQEQ='=='
  EXCL_EQ='\!='
  LANGLE='<'
  RANGLE='>'
  LE='<='
  GE='>='
  QUEST_NO_WS='\?'
  ADD='\+'
  SUB='-'
  MULT='\*'
  DIV='\/'
  MOD='%'
  INCR='\+\+'
  DECR='--'
  EXCL_WS='\!' Hidden
  EXCL_NO_WS='\!'
  ARROW='->'
  LSQUARE='\['
  RSQUARE=']'
  RANGE='\.\.'

  NL="regexp:'\n'|'\r''\n'?"

//  Hidden= DelimitedComment | LineComment | WS

  LineComment= "regexp://[^\r\n]*"
//  DelimitedComment='\/\*' ( DelimitedComment | . )*? '\*\/'
  DelimitedComment="regexp:/\* .* \*/"

  WS="regexp:\ | \t | \u000C"
  ]
}

program ::= NL* importList statements NL* EOF

importList ::= importHeader*

importHeader ::= IMPORT identifier (DOT MULT | importAlias)? semi?

importAlias ::= AS simpleIdentifier

declaration ::= classDeclaration | functionDeclaration | propertyDeclaration

propertyDeclaration ::= (VAL | VAR) simpleIdentifier (COLON NL* type)? (NL* (ASSIGNMENT NL* expression))?

functionDeclaration ::= FUN simpleIdentifier functionParameters (COLON NL* type)? functionBody

variableDeclaration ::= simpleIdentifier (NL* COLON NL* type)?

functionBody ::= block | ASSIGNMENT NL* expression

functionParameters ::= LPAREN (functionParameter (NL* COMMA NL* functionParameter)* (NL* COMMA)?)? NL* RPAREN

functionParameter ::= identifier COLON identifier

// SECTION  ::= statements

statement ::= declaration | assignment | expression

assignment ::= identifier ASSIGNMENT expression NL*

statements ::= (statement (semis statement)*)? semis?

block ::= LCURL NL* statements NL* RCURL

// SECTION  ::= classes

classDeclaration ::= CLASS_ simpleIdentifier (primaryConstructor?)
    (COLON delegationSpecifiers)?
    (NL* classBody)?

classBody  ::= LCURL NL* classMemberDeclarations NL* RCURL;

classMemberDeclarations  ::= (classMemberDeclaration NL*)*;

classMemberDeclaration  ::= declaration;

primaryConstructor ::= CONSTRUCTOR? classParameters

classParameters ::= LPAREN NL* (classParameter (NL* COMMA NL* classParameter)* (NL* COMMA)?)? NL* RPAREN

classParameter ::= (VAL | VAR)? simpleIdentifier COLON NL* type (NL* ASSIGNMENT NL* expression)?

delegationSpecifiers ::= delegationSpecifier (NL* COMMA NL* delegationSpecifier)*

delegationSpecifier ::= simpleIdentifier constructorInvocation

constructorInvocation ::= functionParameters

// SECTION  ::= expressions

expression ::= disjunction

disjunction ::= conjunction (NL* DISJ NL* conjunction)*

conjunction ::= equality (NL* CONJ NL* equality)*

equality ::= comparison (equalityOperator NL* comparison)*

comparison ::= genericCallLikeComparison (comparisonOperator NL* genericCallLikeComparison)*

genericCallLikeComparison ::= infixOperation

infixOperation ::= elvisExpression (inOperator NL* elvisExpression | isOperator NL* type)*

elvisExpression ::= infixFunctionCall (NL* elvis NL* infixFunctionCall)*

infixFunctionCall ::= rangeExpression (simpleIdentifier NL* rangeExpression)*

rangeExpression ::= additiveExpression (RANGE NL* additiveExpression)*

additiveExpression ::= multiplicativeExpression (additiveOperator NL* multiplicativeExpression)*

multiplicativeExpression ::= asExpression (multiplicativeOperator NL* asExpression)*

asExpression ::= prefixUnaryExpression (NL* asOperator NL* type)*

prefixUnaryExpression ::= unaryPrefix* postfixUnaryExpression

postfixUnaryExpression ::= primaryExpression postfixUnarySuffix*

postfixUnarySuffix ::= postfixUnaryOperator
    | callSuffix
    | navigationSuffix

navigationSuffix ::= memberAccessOperator NL* (CLASS_ | parenthesizedExpression | simpleIdentifier)

unaryPrefix ::= prefixUnaryOperator NL*

primaryExpression ::= parenthesizedExpression
    | literalConstant
    | stringLiteral
    | collectionLiteral
    | thisExpression
    | superExpression
    | ifExpression
    | whenExpression
    | tryExpression
    | jumpExpression
    | simpleIdentifier

parenthesizedExpression ::= LPAREN NL* expression NL* RPAREN

literalConstant ::= BooleanLiteral
    | IntegerLiteral
    | NullLiteral

stringLiteral ::= StringLiteral

collectionLiteral ::= LSQUARE NL* (expression (NL* COMMA NL* expression)* (NL* COMMA)? NL*)? RSQUARE

thisExpression ::= THIS

superExpression ::= SUPER (LANGLE NL* type NL* RANGLE)?

ifExpression ::= IF NL* LPAREN NL* expression NL* RPAREN NL*
      ( controlStructureBody? NL* SEMICOLON? NL* ELSE NL* (SEMICOLON | controlStructureBody)
      | SEMICOLON
      | controlStructureBody
      )

controlStructureBody ::= block
    | statement

whenExpression ::= WHEN NL* whenSubject? NL* LCURL NL* (whenEntry NL*)* NL* RCURL

whenSubject ::= LPAREN (NL* VAL NL* variableDeclaration NL* ASSIGNMENT NL*)? expression RPAREN

whenEntry ::= whenCondition (NL* COMMA NL* whenCondition)* (NL* COMMA)? NL* ARROW NL* controlStructureBody semi?
    | ELSE NL* ARROW NL* controlStructureBody semi?

whenCondition ::= rangeTest
    | typeTest
    | expression

rangeTest ::= inOperator NL* expression

typeTest ::= isOperator NL* type

tryExpression ::= TRY NL* block ((NL* catchBlock)+ (NL* finallyBlock)? | NL* finallyBlock)

catchBlock ::= CATCH NL* LPAREN simpleIdentifier COLON type (NL* COMMA)? RPAREN NL* block

finallyBlock ::= FINALLY NL* block

jumpExpression ::= THROW NL* expression
    | RETURN expression?
    | CONTINUE
    | BREAK

callSuffix ::= valueArguments

valueArguments ::= LPAREN NL* (valueArgument (NL* COMMA NL* valueArgument)* (NL* COMMA)? NL*)? RPAREN

valueArgument ::= (simpleIdentifier NL* ASSIGNMENT NL*)? MULT? NL* expression

elvis ::= QUEST_NO_WS COLON

equalityOperator ::= EXCL_EQ
    | EQEQ

comparisonOperator ::= LANGLE
    | RANGLE
    | LE
    | GE

inOperator ::= IN
    | NOT_IN

isOperator ::= IS
    | NOT_IS

asOperator ::= AS
    | AS_SAFE

additiveOperator ::= ADD
    | SUB

multiplicativeOperator ::= MULT
    | DIV
    | MOD

prefixUnaryOperator ::= SUB
    | ADD
    | excl

postfixUnaryOperator ::= INCR
    | DECR
    | EXCL_NO_WS

excl ::= EXCL_NO_WS
    | EXCL_WS

semi ::= (SEMICOLON | NL) NL*

memberAccessOperator ::= NL* DOT
    | COLONCOLON

semis ::= (SEMICOLON | NL)+

// SECTION  ::= types

type ::= simpleIdentifier QUEST?

// SECTION  ::= characters

//Letter  ::=  "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N"
//         | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
//         | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p"
//         | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
//
//Digit  ::=  "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
//Symbol  ::=   "|" | " " | "!" | "#" | "$" | "%" | "&" | "(" | ")" | "*" | "+" | "," | "-" | "."
//          | "/" | ":" | ";" | ">" | "=" | "<" | "?" | "@" | "[" | "\\" | "]" | "^" | "_" | "`"
//          | "{" | "}" | "~";
//
//// SECTION  ::= literals
//
//BooleanLiteral  ::= 'true'| 'false';
//
//NullLiteral  ::= 'null';
//
//IntegerLiteral
//     ::=  '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
//        [{'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'}]
//    | '0'
//
//StringLiteral ::= STRING
//
//// SECTION  ::= keywords
//
//IMPORT  ::= 'import';
//CLASS_  ::= 'class';
//INTERFACE  ::= 'interface';
//FUN  ::= 'fun';
//CONSTRUCTOR  ::= 'constructor';
//IF  ::= 'if';
//ELSE  ::= 'else';
//TRY  ::= 'try';
//CATCH  ::= 'catch';
//FINALLY  ::= 'finally';
//FOR  ::= 'for';
//RETURN  ::= 'return';
//IS  ::= 'is';
//IN  ::= 'in';
//NOT_IS  ::= '!is' (Hidden | NL);
//NOT_IN  ::= '!in' (Hidden | NL);
//AS  ::= 'as';
//AS_SAFE  ::= 'as?';
//THIS  ::= 'this';
//SUPER  ::= 'super';
//THROW  ::= 'throw';
//CONTINUE  ::= 'continue';
//BREAK  ::= 'break';
//WHEN  ::= 'when';
//
//// SECTION  ::= lexicalModifiers
//
//PUBLIC  ::= 'public';
//PRIVATE_  ::= 'private';
//PROTECTED  ::= 'protected';
//
//VAL  ::= 'val';
//VAR  ::= 'var';
//
//STRING  ::= '"' [{Letter | Symbol | Digit}] '"';
//
//LPAREN  ::= '(';
//RPAREN  ::= ')';
//LCURL  ::= '{';
//RCURL  ::= '}';
//COMMA  ::= ',';
//COLON  ::= ':';
//COLONCOLON  ::= '::';
//ASSIGNMENT  ::= '=';
//QUEST  ::= '?' Hidden;
//CONJ  ::= '&&';
//DISJ  ::= '||';
//SEMICOLON  ::= ';';
//DOT  ::= '.';
//QUOTE  ::= '"';
//EQEQ  ::= '==';
//EXCL_EQ  ::= '!=';
//LANGLE  ::= '<';
//RANGLE  ::= '>';
//LE  ::= '<=';
//GE  ::= '>=';
//QUEST_NO_WS  ::= '?';
//ADD  ::= '+';
//SUB  ::= '-';
//MULT  ::= '*';
//DIV  ::= '/';
//MOD  ::= '%';
//INCR  ::= '++';
//DECR  ::= '--';
//EXCL_WS  ::= '!' Hidden;
//EXCL_NO_WS  ::= '!';
//ARROW  ::= '->';
//LSQUARE  ::= '[';
//RSQUARE  ::= ']';
//RANGE  ::= '..';
//
//NL  ::= '\n' | '\r' '\n'?;
//
//Hidden  ::=  DelimitedComment | LineComment | WS;
//
//
//LineComment ::=  COMMENT // todo
//
//DelimitedComment ::=  COMMENT // todo

//WS	  ::= 	(' '| '\t' | '\u000C') -> skip
//	; todo

// SECTION  ::= lexicalIdentifiers

identifier ::= simpleIdentifier (NL* DOT simpleIdentifier)*

simpleIdentifier ::= Identifier

Identifier ::=  Letter [{'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'} | Letter]
//    | '`' ~([\r\n] | '`')+ '`'

